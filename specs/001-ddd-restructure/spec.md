# Feature Specification: コードベースの保守性向上とアーキテクチャ明確化

**Feature Branch**: `001-ddd-restructure`
**Created**: 2025-12-30
**Status**: Draft
**Input**: User description: "DDDの形式でディレクトリ構成を変更したいです
app
_repositories
_services
みたいな感じでdddにしてください"

**注意**: この仕様書は、内部アーキテクチャのリファクタリングを扱うため、技術的な内容が含まれます。エンドユーザーには直接的な影響はありませんが、長期的な開発効率とコード品質向上を目的としています。

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 開発者がドメインロジックを明確に識別できる (Priority: P1)

開発者がプロジェクトを開き、ビジネスロジックがどこにあるかを直感的に理解できるようにする。DDD層構造により、ドメインモデル、アプリケーションサービス、インフラストラクチャが明確に分離される。

**Why this priority**: コードベースの保守性と可読性の基盤となる最も重要な変更。これがないと他の改善も効果が薄い。

**Independent Test**: 新しいディレクトリ構造を確認し、各レイヤーが適切に分離されていることを目視で検証できる。開発者がドメインモデルを探す際に、迷わず該当ディレクトリにアクセスできる。

**Acceptance Scenarios**:

1. **Given** 開発者がプロジェクトのルートディレクトリを開いた時、**When** srcディレクトリを確認する、**Then** domain、application、infrastructure、presentationの各レイヤーディレクトリが存在する
2. **Given** 開発者がビジネスロジックを探している時、**When** domainディレクトリを開く、**Then** エンティティ、値オブジェクト、ドメインサービスが整理されて配置されている
3. **Given** 開発者がデータアクセスロジックを確認したい時、**When** infrastructureディレクトリを開く、**Then** repositoriesフォルダ内にリポジトリ実装が配置されている

---

### User Story 2 - 既存機能が新しい構造で正常に動作する (Priority: P2)

すべての既存機能（認証、セッション管理、プロジェクト管理など）が新しいディレクトリ構造でも変わらず動作する。エンドユーザーは変更に気づかない。

**Why this priority**: リファクタリングによる機能破壊を防ぐため、P1の次に重要。ユーザー体験を維持しながら内部構造を改善する。

**Independent Test**: 既存のE2Eテストを実行し、すべてが通過することを確認。または手動で主要フロー（ログイン、セッション作成、見積もり投稿）を実行して動作確認。

**Acceptance Scenarios**:

1. **Given** ユーザーがログインページにアクセスした時、**When** 認証情報を入力してログインする、**Then** 正常にマイページにリダイレクトされる
2. **Given** 認証済みユーザーがセッションを作成した時、**When** セッション詳細ページにアクセスする、**Then** セッション情報が正しく表示される
3. **Given** ユーザーが見積もりを投稿した時、**When** 他の参加者がページを更新する、**Then** 投稿された見積もりが反映される

---

### User Story 3 - 開発者が新機能を適切なレイヤーに追加できる (Priority: P3)

新しいDDD構造により、開発者が新機能を追加する際に、どのレイヤーにどのコードを配置すべきかが明確になる。

**Why this priority**: P1とP2が完了した後に初めて価値を発揮する。長期的なコード品質維持に貢献。

**Independent Test**: サンプル機能（例：新しいエンティティの追加）を実装し、各レイヤーに適切にコードが配置されることを確認。

**Acceptance Scenarios**:

1. **Given** 開発者が新しいエンティティを追加する時、**When** domain層に配置する、**Then** ビジネスルールがエンティティ内にカプセル化される
2. **Given** 開発者がデータ取得ロジックを実装する時、**When** infrastructure/repositoriesに配置する、**Then** ドメイン層がインフラストラクチャの詳細に依存しない
3. **Given** 開発者がユースケースを実装する時、**When** application層に配置する、**Then** アプリケーションロジックがドメインロジックとインフラストラクチャから分離される

---

### Edge Cases

- 既存のimport文が新しいパス構造で正しく解決されない場合はどうするか？
- Next.js App Routerの規約（appディレクトリ）とDDD構造をどう共存させるか？
- Prismaクライアントなどの既存の共有モジュールをどのレイヤーに配置するか？
- APIルート（app/api）のコードをどうDDD構造に組み込むか？
- 既存のユーティリティ関数（lib/utils.ts）をどのレイヤーに移行するか？
- 機能移行中に他の開発者が同じファイルを編集した場合のマージ競合をどう解決するか？
- すべてのPrisma呼び出しをリポジトリ化する際、複雑なクエリ（JOIN、トランザクション）をどう扱うか？
- 移行後のテスト追加時に重大なバグが発見された場合、切り戻すか修正で対応するか？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、src/domain ディレクトリにドメイン層（エンティティ、値オブジェクト、ドメインサービス、リポジトリインターフェース）を配置しなければならない
- **FR-002**: システムは、src/application ディレクトリにアプリケーション層（ユースケース、アプリケーションサービス、DTOs）を配置しなければならない
- **FR-003**: システムは、src/infrastructure ディレクトリにインフラストラクチャ層（リポジトリ実装、データベース接続、外部API統合）を配置しなければならない
- **FR-004**: システムは、app ディレクトリをプレゼンテーション層として維持し、Next.js App Routerの規約を遵守しなければならない
- **FR-005**: すべての既存機能は、ディレクトリ構造変更後も同じ動作を維持しなければならない
- **FR-006**: import文は新しいディレクトリ構造に対応し、TypeScriptパスエイリアス（@/domain、@/application、@/infrastructureなど）を使用しなければならない
- **FR-007**: 既存のAPIエンドポイント（app/api配下）は、application層のサービスを呼び出す薄いコントローラーとして機能しなければならない
- **FR-008**: Prismaクライアントはinfrastructure層に配置され、リポジトリパターンを通じてのみアクセスされなければならない
- **FR-009**: 認証ロジック（NextAuth設定）は、infrastructure層またはapplication層に適切に配置されなければならない
- **FR-010**: ドメイン層はインフラストラクチャ層やプレゼンテーション層に依存してはならない（依存性逆転の原則）
- **FR-011**: app/components配下のReactコンポーネントは、Next.jsの規約に従いappディレクトリ内に維持しなければならない
- **FR-012**: ユーティリティ関数は、各レイヤー内に分散配置され（domain/utils、infrastructure/utils、application/utils）、レイヤー境界を越えた共有を避けなければならない
- **FR-013**: middleware.tsのロジックは、application層に配置され、ルート直下のmiddleware.tsファイルから参照される形式でなければならない
- **FR-014**: リファクタリングは機能単位（認証→セッション→プロジェクト管理の順）で段階的に実施し、各機能の移行は混在期間を設けず一気に完了させなければならない
- **FR-015**: すべてのPrisma呼び出しは、移行時に一度にリポジトリパターンに変換されなければならない（段階的な部分適用は行わない）
- **FR-016**: 移行後にテストスイートを整備し、SC-001（すべてのテスト100%通過）を達成しなければならない

### Key Entities

- **ドメイン層 (Domain Layer)**: ビジネスロジックの中核。エンティティ（User、Project、EstimationSession、Estimate）、値オブジェクト、ドメインサービス、リポジトリインターフェースを含む
- **アプリケーション層 (Application Layer)**: ユースケースの調整。ドメインオブジェクトを使用してビジネスフローを実行するアプリケーションサービスを含む
- **インフラストラクチャ層 (Infrastructure Layer)**: 技術的な実装詳細。Prismaリポジトリ実装、データベース接続、NextAuth設定、外部API統合を含む
- **プレゼンテーション層 (Presentation Layer)**: UIとAPIエンドポイント。Next.js App Router（app ディレクトリ）、React コンポーネント、API routesを含む

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: すべての既存テストが構造変更後も100%通過する（機能破壊がないことを保証）
- **SC-002**: 開発者が新しいビジネスロジックを追加する際、適切な配置場所を5分以内に特定できる
- **SC-003**: コードの依存関係が明確に分離され、モジュール境界が80%以上のファイルで識別可能
- **SC-004**: 既存機能（ログイン、セッション作成、見積もり投稿）がリファクタリング前と同じパフォーマンスとレスポンス時間で動作する
- **SC-005**: ビジネスロジックが技術的な実装詳細に依存せず、独立してテスト可能

## Scope *(optional)*

### In Scope

- 既存のコードファイルを新しいDDD構造に移動・再配置
- TypeScript パスエイリアスの設定追加（tsconfig.json）
- import文の一括更新
- 既存のビジネスロジックのリポジトリパターンへの抽出
- Next.js App Router（appディレクトリ）との共存設計

### Out of Scope

- 新機能の追加
- UIデザインの変更
- データベーススキーマの変更
- パフォーマンス最適化（構造変更に伴う必要最小限を除く）
- 完全なDDD戦略的設計（境界づけられたコンテキスト、集約の再設計など）- 将来フェーズで対応

## Assumptions *(optional)*

1. 現在のコードベースはレイヤー化されていない、または暗黙的なレイヤー構造のみ存在する
2. テストスイートは移行後に整備する（移行前のテストカバレッジは問わない）
3. 開発チームはDDDの基本概念（エンティティ、値オブジェクト、リポジトリ、レイヤー分離）を理解している
4. Next.js App Routerの制約（appディレクトリ構造）を維持する必要がある
5. 機能単位での段階的移行を採用し、各機能の移行は混在期間なしに一気に完了させる（認証→セッション→プロジェクト管理の順）
6. Prisma ORMを継続使用し、すべてのPrisma呼び出しを一度にリポジトリパターンに変換する
7. 既存のNext.js、React、TypeScriptのバージョンを変更しない
8. リファクタリング失敗時はGitブランチごと切り戻し、全体を元の状態に戻す方針を採用

## Dependencies *(optional)*

- 既存のTypeScript 5.x設定
- Next.js 16.x App Router
- Prisma 6.x ORM
- NextAuth.js v4.x（認証基盤）
- 既存のテストフレームワーク（未確認だが、理想的にはJest/Vitest、Playwright等）

## Non-Functional Requirements *(optional)*

- **保守性**: 新しい構造により、コードの保守性が向上し、技術的負債が減少する
- **拡張性**: 新機能を追加する際に、適切なレイヤーに配置することで拡張が容易になる
- **テスタビリティ**: レイヤー分離により、各レイヤーを独立してテストできる。移行後にテストスイートを整備し、100%のテスト通過率を達成する
- **学習曲線**: 新しい開発者がコードベースを理解する時間が50%短縮される（主観的だが、ディレクトリ構造の明確さにより）
- **移行リスク**: 機能単位の段階的移行（認証→セッション→プロジェクト管理）により、本番環境への影響を最小限に抑える。各機能の移行は混在期間を設けず一気に完了させることで、移行期間中の複雑さを低減
- **ロールバック戦略**: 重大な問題発生時はGitブランチごと切り戻し、全体を元の状態に復旧できる体制を維持

## Clarifications

### Session 2025-12-30

- Q: リファクタリングの移行アプローチ → A: 機能単位（認証→セッション→プロジェクト）で段階的に移行
- Q: 既存テストが不足している場合の対応 → A: テストなしで移行を進め、移行後にテストを追加
- Q: リファクタリング失敗時のロールバック戦略 → A: Gitブランチごと切り戻し（全体を元の状態に戻す）
- Q: リポジトリパターンの適用スコープ → A: すべてのPrisma呼び出しを一度にリポジトリパターンに変換
- Q: 移行期間中の新旧構造の並行稼働期間 → A: 混在期間を設けない（各機能の移行は一気に完了させる）

## Clarifications Resolved

### Reactコンポーネントの配置
**決定**: appディレクトリ内に維持（Next.js規約優先）

**理由**: Next.jsの標準構造を維持することで、フレームワークの規約に従い、学習コストを低く抑える。app/components配下のコンポーネントはそのまま維持し、プレゼンテーション層として扱う。

### ユーティリティ関数の配置
**決定**: 各レイヤー内に分散配置（domain/utils、infrastructure/utils等）

**理由**: レイヤー境界を厳密に保つことで、依存関係を明確にする。ユーティリティ関数が特定のレイヤーに属することが明確になり、意図しない依存を防ぐ。ドメインロジックで使用するユーティリティはdomain/utils、インフラストラクチャ関連はinfrastructure/utils、アプリケーション層で使用するものはapplication/utilsに配置。

### middleware.tsの配置
**決定**: ロジックをapplication層に移動し、ルートのmiddleware.tsから参照

**理由**: 認証・認可はアプリケーション層の責務として扱い、ビジネスルール（どのルートが保護されるべきか等）とインフラストラクチャ（NextAuthの実装詳細）を分離する。ルート直下のmiddleware.tsは薄いラッパーとして、application層のロジックを呼び出す形式とする。これにより、認証ロジックを独立してテストできる。
